"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const config_1 = __importDefault(require("../config"));
const sleep_1 = __importDefault(require("../common/sleep"));
/**
 * Handle the TagoIO Response
 * @internal
 * @param result Axios Result
 */
function resultHandler(result) {
    if (!result.data) {
        throw result.statusText;
    }
    if (result.status === 200 && result.config.url.includes("/data/export")) {
        return { data: result.data };
    }
    if (result.data.status !== true) {
        return result.data.message || result.data.result || result.data;
    }
    return { data: result.data.result };
}
/**
 * Handle all request to TagoIO API
 * @internal
 * @param axiosObj Axios Object
 */
async function apiRequest(axiosObj) {
    axiosObj.timeout = config_1.default.requestTimeout;
    // Prevent cache on IE
    axiosObj.headers = Object.assign(Object.assign({}, axiosObj.headers), { Pragma: "no-cache", "Cache-Control": "no-cache" });
    const request = () => {
        return axios_1.default(axiosObj)
            .then(resultHandler)
            .catch((error) => ({ error }));
    };
    let result;
    let resulterror;
    for (let i = 1; i <= config_1.default.requestAttempts; i += 1) {
        const { data, error } = await request();
        if (!error) {
            result = data;
            break;
        }
        if (error.response) {
            resulterror = {
                from: "SERVER_RESPONSE",
                url: error.config.url,
                method: String(error.config.method).toUpperCase(),
                status: error.response.status,
                code: error.code || "UNKNOWN",
                statusText: error.response.statusText,
            };
        }
        else {
            resulterror = {
                from: "CLIENT_REQUEST",
                url: error.config.url,
                method: String(error.config.method).toUpperCase(),
                status: -1,
                code: error.code || "UNKNOWN",
                statusText: "UNKNOWN",
            };
        }
        // ? Requests with client errors not retry.
        if (error.response && (error.response.status >= 400 || error.response.status < 500)) {
            resulterror = resultHandler(error.response);
            break;
        }
        await sleep_1.default(1500);
    }
    if (!result && resulterror) {
        throw resulterror;
    }
    return result;
}
exports.default = apiRequest;
//# sourceMappingURL=apiRequest.js.map